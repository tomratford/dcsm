---
title: "Mean Squared Error for a Weibull baseline intensity"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Mean Squared Error for a Weibull baseline intensity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
library(survival)
```

```{r simulate_linear_data, eval=F}
N <- 100

# true values
lambda01 <- 4
lambda02 <- 1
lambda12 <- 0.5
theta01 <- log(0.4)
theta02 <- log(0.4)
theta12 <- log(1)

# true survivor function
logS_t <- \(t,z) {
  -(lambda01*exp(z*theta01) + lambda02*exp(z*theta02))*t
}

No_visits <- 8

mse <- matrix(nrow=N,ncol=7)
colnames(mse) <- c("Weib", "KM PFS", "Cox PFS", "theta01", "theta02", "theta12", "theta")
set.seed(123)
i <- 1
while (i <= N) {
  print(i)
  dat <- sim_exp(N = 300,
                 lambda01,
                 lambda02,
                 lambda12,
                 theta01,
                 theta02,
                 theta12,
                 K = No_visits)
  
  # get KM error
  km <- survfit(Surv(PFSDY, PFS) ~ ATRTN, data=dat)
  km_resid <- exp(logS_t(km$time, c(rep(0,km$strata[1]),rep(1,km$strata[2])))) - km$surv
  
  cox_mod <- coxph(Surv(PFSDY, PFS) ~ ATRTN, data=dat)
  theta <- unname(cox_mod$coef)
  cox_resid <- exp(logS_t(dat$PFSDY, dat$ATRTN)) - predict(cox_mod, type="survival")
  
  fit <- try(joly.fit(dat,0,0,0,3,5,5,compute_cross = F))
  if (class(fit) == "try-error") next # break early if it doesn't work
  pars <- make_pars2(fit$par, joly.initials(dat,0,0,0))
  fns <- do.call(joly.fnBuilder,pars)
  
  fitted <- fns$P00(rep(0,length(dat$PFSDY)), dat$PFSDY, dat$ATRTN)
  resid <-  exp(logS_t(dat$PFSDY, dat$ATRTN)) - fitted
  mse[i,] <- c(mean(resid^2),mean(km_resid^2), mean(cox_resid^2), fit$par[["theta01"]], fit$par[["theta02"]], fit$par[["theta12"]], theta) 
  i <- i+1
}
mse_joly_exp <- mse
```

```{r plot_linear_density}
plot(density(log(mse_joly_exp[,1])))
lines(density(log(mse_joly_exp[,2])), col="red")
```

```{r simulate_nonlinear_data, eval=F}
N <- 100

# true values
a01 <- \(x) x^(4/5)
A01 <- \(x) (5/9)*x^(9/5)
a02 <- \(x) 3*x/4
A02 <- \(x) (3*(x^2))/8
a12 <- \(x) (3*x/2)^(5/4)
A12 <- \(x) ((2/3)^(3/4))*(x^(9/4))
theta01 <- log(0.4)
theta02 <- log(0.4)
theta12 <- log(1)

# true survivor function
logS_t <- \(t,z) {
  -(A01(t)*exp(z*theta01) + A02(t)*exp(z*theta02))
}

No_visits <- 8

mse <- matrix(nrow=N,ncol=7)
colnames(mse) <- c("Weib", "KM PFS", "Cox PFS", "theta01", "theta02", "theta12", "theta")
set.seed(123)
for (i in 1:N) {
  print(i)
  dat <- sim_nonlinear(N = 300,
                       a01,
                       A02,
                       a02,
                       A02,
                       a12,
                       A12,
                       theta01,
                       theta02,
                       theta12,
                       K = No_visits)
  
  # get KM error
  km <- survfit(Surv(PFSDY, PFS) ~ ATRTN, data=dat)
  km_resid <- exp(logS_t(km$time, c(rep(0,km$strata[1]),rep(1,km$strata[2])))) - km$surv
  
  cox_mod <- coxph(Surv(PFSDY, PFS) ~ ATRTN, data=dat)
  theta <- unname(cox_mod$coef)
  cox_resid <- exp(logS_t(dat$PFSDY, dat$ATRTN)) - predict(cox_mod, type="survival")
  
  fit <- joly.fit(dat,1,0,1,5,3,5,compute_cross = F)
  fns <- do.call(joly.fnBuilder,make_pars2(fit$par,joly.initials(dat,1,0,1)))
  
  fitted <- fns$P00(rep(0,length(dat$PFSDY)), dat$PFSDY, dat$ATRTN)
  resid <-  exp(logS_t(dat$PFSDY, dat$ATRTN)) - fitted
  mse[i,] <- c(mean(resid^2),mean(km_resid^2), mean(cox_resid^2), fit$par[["theta01"]], fit$par[["theta02"]], fit$par[["theta12"]], theta) 
}
mse_joly_nonlinear <- mse
```

```{r plot_nonlinear_density}
plot(density(log(mse[,1])))
lines(density(log(mse[,2])), col="red")
```
